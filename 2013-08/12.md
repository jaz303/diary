## Monday 12 August 2013

### Clojure

Doing day 3 of Clojure in 7L7W.

#### STM

  * Create a reference: `(def foo (ref "foo"))`
  * Dereference: `(deref foo)`
  * Dereference: `@foo`
  * Update: `(dosync (ref-set foo "bar"))`
    * `dosync` wraps sub-expression in a transaction
  * `(alter foo fn arg)` =&gt; `(fn existing-deref-value-of-foo arg)`
  * Create an atom: `(def bleem (atom "bleem"))`
  * Dereference: `@bleem`
  * Update: `(reset! bleem "RAAAA")`
    * no transaction necessary
  * `(swap! foo fn arg)` =&gt; `alter` for atoms

#### Agents

    (defn twice [x] (* 2 x))
    (def tribbles (agent 1))
    (send tribbles twice)
    @tribbles

A function sent to an agent will be called with the existing state of the agent and should return its new state.

Not guaranteed to get the _latest_ value for the agent, just _a_ value. To wait for the latest value, use either of the following:

    (await tribbles)
    (await-for timeout tribbles)

#### Futures

    (def delayed-10 (future (Thread/sleep 5000) 10))

#### Things the book says is hasn't covered

  * Metadata - metadata can be attached to symbols and collections
  * Java integration
  * Multimethods - can apparently be used to implement various forms of inheritance
  * Thread state - can use `vars` to associate names with the current thread only.
